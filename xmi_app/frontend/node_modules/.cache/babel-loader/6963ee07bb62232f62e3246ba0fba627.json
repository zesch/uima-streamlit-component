{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\n\nconst wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\n\nfunction pd(event) {\n  const retv = privateData.get(event);\n  console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\n\n\nfunction setCancelFlag(data) {\n  if (data.passiveListener != null) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n    }\n\n    return;\n  }\n\n  if (!data.event.cancelable) {\n    return;\n  }\n\n  data.canceled = true;\n\n  if (typeof data.event.preventDefault === \"function\") {\n    data.event.preventDefault();\n  }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\n\n\nfunction Event(eventTarget, event) {\n  privateData.set(this, {\n    eventTarget,\n    event,\n    eventPhase: 2,\n    currentTarget: eventTarget,\n    canceled: false,\n    stopped: false,\n    immediateStopped: false,\n    passiveListener: null,\n    timeStamp: event.timeStamp || Date.now()\n  }); // https://heycam.github.io/webidl/#Unforgeable\n\n  Object.defineProperty(this, \"isTrusted\", {\n    value: false,\n    enumerable: true\n  }); // Define accessors\n\n  const keys = Object.keys(event);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in this)) {\n      Object.defineProperty(this, key, defineRedirectDescriptor(key));\n    }\n  }\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEvent.prototype = {\n  /**\n   * The type of this event.\n   * @type {string}\n   */\n  get type() {\n    return pd(this).event.type;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get target() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    return pd(this).currentTarget;\n  },\n\n  /**\n   * @returns {EventTarget[]} The composed path of this event.\n   */\n  composedPath() {\n    const currentTarget = pd(this).currentTarget;\n\n    if (currentTarget == null) {\n      return [];\n    }\n\n    return [currentTarget];\n  },\n\n  /**\n   * Constant of NONE.\n   * @type {number}\n   */\n  get NONE() {\n    return 0;\n  },\n\n  /**\n   * Constant of CAPTURING_PHASE.\n   * @type {number}\n   */\n  get CAPTURING_PHASE() {\n    return 1;\n  },\n\n  /**\n   * Constant of AT_TARGET.\n   * @type {number}\n   */\n  get AT_TARGET() {\n    return 2;\n  },\n\n  /**\n   * Constant of BUBBLING_PHASE.\n   * @type {number}\n   */\n  get BUBBLING_PHASE() {\n    return 3;\n  },\n\n  /**\n   * The target of this event.\n   * @type {number}\n   */\n  get eventPhase() {\n    return pd(this).eventPhase;\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopPropagation() {\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.stopPropagation === \"function\") {\n      data.event.stopPropagation();\n    }\n  },\n\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopImmediatePropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    data.immediateStopped = true;\n\n    if (typeof data.event.stopImmediatePropagation === \"function\") {\n      data.event.stopImmediatePropagation();\n    }\n  },\n\n  /**\n   * The flag to be bubbling.\n   * @type {boolean}\n   */\n  get bubbles() {\n    return Boolean(pd(this).event.bubbles);\n  },\n\n  /**\n   * The flag to be cancelable.\n   * @type {boolean}\n   */\n  get cancelable() {\n    return Boolean(pd(this).event.cancelable);\n  },\n\n  /**\n   * Cancel this event.\n   * @returns {void}\n   */\n  preventDefault() {\n    setCancelFlag(pd(this));\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    return pd(this).canceled;\n  },\n\n  /**\n   * The flag to be composed.\n   * @type {boolean}\n   */\n  get composed() {\n    return Boolean(pd(this).event.composed);\n  },\n\n  /**\n   * The unix time of this event.\n   * @type {number}\n   */\n  get timeStamp() {\n    return pd(this).timeStamp;\n  },\n\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   * @deprecated\n   */\n  get srcElement() {\n    return pd(this).eventTarget;\n  },\n\n  /**\n   * The flag to stop event bubbling.\n   * @type {boolean}\n   * @deprecated\n   */\n  get cancelBubble() {\n    return pd(this).stopped;\n  },\n\n  set cancelBubble(value) {\n    if (!value) {\n      return;\n    }\n\n    const data = pd(this);\n    data.stopped = true;\n\n    if (typeof data.event.cancelBubble === \"boolean\") {\n      data.event.cancelBubble = true;\n    }\n  },\n\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   * @deprecated\n   */\n  get returnValue() {\n    return !pd(this).canceled;\n  },\n\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag(pd(this));\n    }\n  },\n\n  /**\n   * Initialize this event object. But do nothing under event dispatching.\n   * @param {string} type The event type.\n   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n   * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n   * @deprecated\n   */\n  initEvent() {// Do nothing.\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(Event.prototype, \"constructor\", {\n  value: Event,\n  configurable: true,\n  writable: true\n}); // Ensure `event instanceof window.Event` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, window.Event.prototype); // Make association for wrappers.\n\n  wrappers.set(window.Event.prototype, Event);\n}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\n\n\nfunction defineRedirectDescriptor(key) {\n  return {\n    get() {\n      return pd(this).event[key];\n    },\n\n    set(value) {\n      pd(this).event[key] = value;\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\n\n\nfunction defineCallDescriptor(key) {\n  return {\n    value() {\n      const event = pd(this).event;\n      return event[key].apply(event, arguments);\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\n\n\nfunction defineWrapper(BaseEvent, proto) {\n  const keys = Object.keys(proto);\n\n  if (keys.length === 0) {\n    return BaseEvent;\n  }\n  /** CustomEvent */\n\n\n  function CustomEvent(eventTarget, event) {\n    BaseEvent.call(this, eventTarget, event);\n  }\n\n  CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n    constructor: {\n      value: CustomEvent,\n      configurable: true,\n      writable: true\n    }\n  }); // Define accessors.\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (!(key in BaseEvent.prototype)) {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n      const isFunc = typeof descriptor.value === \"function\";\n      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n    }\n  }\n\n  return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\n\n\nfunction getWrapper(proto) {\n  if (proto == null || proto === Object.prototype) {\n    return Event;\n  }\n\n  let wrapper = wrappers.get(proto);\n\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n    wrappers.set(proto, wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\n\n\nfunction wrapEvent(eventTarget, event) {\n  const Wrapper = getWrapper(Object.getPrototypeOf(event));\n  return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\n\n\nfunction isStopped(event) {\n  return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\n\n\nfunction setEventPhase(event, eventPhase) {\n  pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\n\n\nfunction setCurrentTarget(event, currentTarget) {\n  pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\n\n\nfunction setPassiveListener(event, passiveListener) {\n  pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\n\n\nconst listenersMap = new WeakMap(); // Listener types\n\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\n\nfunction isObject(x) {\n  return x !== null && typeof x === \"object\"; //eslint-disable-line no-restricted-syntax\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\n\n\nfunction getListeners(eventTarget) {\n  const listeners = listenersMap.get(eventTarget);\n\n  if (listeners == null) {\n    throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n  }\n\n  return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\n\n\nfunction defineEventAttributeDescriptor(eventName) {\n  return {\n    get() {\n      const listeners = getListeners(this);\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          return node.listener;\n        }\n\n        node = node.next;\n      }\n\n      return null;\n    },\n\n    set(listener) {\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        listener = null; // eslint-disable-line no-param-reassign\n      }\n\n      const listeners = getListeners(this); // Traverse to the tail while removing old value.\n\n      let prev = null;\n      let node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          // Remove old value.\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners.delete(eventName);\n          }\n        } else {\n          prev = node;\n        }\n\n        node = node.next;\n      } // Add new value.\n\n\n      if (listener !== null) {\n        const newNode = {\n          listener,\n          listenerType: ATTRIBUTE,\n          passive: false,\n          once: false,\n          next: null\n        };\n\n        if (prev === null) {\n          listeners.set(eventName, newNode);\n        } else {\n          prev.next = newNode;\n        }\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\n\n\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\n\n\nfunction defineCustomEventTarget(eventNames) {\n  /** CustomEventTarget */\n  function CustomEventTarget() {\n    EventTarget.call(this);\n  }\n\n  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n    constructor: {\n      value: CustomEventTarget,\n      configurable: true,\n      writable: true\n    }\n  });\n\n  for (let i = 0; i < eventNames.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n  }\n\n  return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\n\n\nfunction EventTarget() {\n  /*eslint-disable consistent-return */\n  if (this instanceof EventTarget) {\n    listenersMap.set(this, new Map());\n    return;\n  }\n\n  if (arguments.length === 1 && Array.isArray(arguments[0])) {\n    return defineCustomEventTarget(arguments[0]);\n  }\n\n  if (arguments.length > 0) {\n    const types = new Array(arguments.length);\n\n    for (let i = 0; i < arguments.length; ++i) {\n      types[i] = arguments[i];\n    }\n\n    return defineCustomEventTarget(types);\n  }\n\n  throw new TypeError(\"Cannot call a class as a function\");\n  /*eslint-enable consistent-return */\n} // Should be enumerable, but class methods are not enumerable.\n\n\nEventTarget.prototype = {\n  /**\n   * Add a given listener to this event target.\n   * @param {string} eventName The event name to add.\n   * @param {Function} listener The listener to add.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  addEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    if (typeof listener !== \"function\" && !isObject(listener)) {\n      throw new TypeError(\"'listener' should be a function or an object.\");\n    }\n\n    const listeners = getListeners(this);\n    const optionsIsObj = isObject(options);\n    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    const newNode = {\n      listener,\n      listenerType,\n      passive: optionsIsObj && Boolean(options.passive),\n      once: optionsIsObj && Boolean(options.once),\n      next: null\n    }; // Set it as the first node if the first node is null.\n\n    let node = listeners.get(eventName);\n\n    if (node === undefined) {\n      listeners.set(eventName, newNode);\n      return;\n    } // Traverse to the tail while checking duplication..\n\n\n    let prev = null;\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        // Should ignore duplication.\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    } // Add it.\n\n\n    prev.next = newNode;\n  },\n\n  /**\n   * Remove a given listener from this event target.\n   * @param {string} eventName The event name to remove.\n   * @param {Function} listener The listener to remove.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  removeEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n\n    const listeners = getListeners(this);\n    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    let prev = null;\n    let node = listeners.get(eventName);\n\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n\n        return;\n      }\n\n      prev = node;\n      node = node.next;\n    }\n  },\n\n  /**\n   * Dispatch a given event.\n   * @param {Event|{type:string}} event The event to dispatch.\n   * @returns {boolean} `false` if canceled.\n   */\n  dispatchEvent(event) {\n    if (event == null || typeof event.type !== \"string\") {\n      throw new TypeError('\"event.type\" should be a string.');\n    } // If listeners aren't registered, terminate.\n\n\n    const listeners = getListeners(this);\n    const eventName = event.type;\n    let node = listeners.get(eventName);\n\n    if (node == null) {\n      return true;\n    } // Since we cannot rewrite several properties, so wrap object.\n\n\n    const wrappedEvent = wrapEvent(this, event); // This doesn't process capturing phase and bubbling phase.\n    // This isn't participating in a tree.\n\n    let prev = null;\n\n    while (node != null) {\n      // Remove this listener if it's once\n      if (node.once) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n      } else {\n        prev = node;\n      } // Call this listener\n\n\n      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n\n      if (typeof node.listener === \"function\") {\n        try {\n          node.listener.call(this, wrappedEvent);\n        } catch (err) {\n          if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(err);\n          }\n        }\n      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n        node.listener.handleEvent(wrappedEvent);\n      } // Break if `event.stopImmediatePropagation` was called.\n\n\n      if (isStopped(wrappedEvent)) {\n        break;\n      }\n\n      node = node.next;\n    }\n\n    setPassiveListener(wrappedEvent, null);\n    setEventPhase(wrappedEvent, 0);\n    setCurrentTarget(wrappedEvent, null);\n    return !wrappedEvent.defaultPrevented;\n  }\n\n}; // `constructor` is not enumerable.\n\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n  value: EventTarget,\n  configurable: true,\n  writable: true\n}); // Ensure `eventTarget instanceof window.EventTarget` is `true`.\n\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };","map":{"version":3,"sources":["../src/event.mjs","../src/event-target.mjs"],"names":[],"mappings":"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","sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"]},"metadata":{},"sourceType":"module"}